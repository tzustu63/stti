<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ç¿»è­¯åŠŸèƒ½èª¿è©¦</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .section {
        margin: 20px 0;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      .log {
        background: #f5f5f5;
        padding: 10px;
        border-radius: 3px;
        max-height: 300px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
      }
      button {
        padding: 10px 20px;
        margin: 5px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      .start {
        background: #4caf50;
        color: white;
      }
      .stop {
        background: #f44336;
        color: white;
      }
      .test {
        background: #2196f3;
        color: white;
      }
    </style>
  </head>
  <body>
    <h1>ç¿»è­¯åŠŸèƒ½èª¿è©¦å·¥å…·</h1>

    <div class="section">
      <h2>WebSocket é€£ç·šç‹€æ…‹</h2>
      <div id="connection-status">æœªé€£ç·š</div>
      <button onclick="connectWebSocket()">é€£ç·š</button>
      <button onclick="disconnectWebSocket()">æ–·ç·š</button>
    </div>

    <div class="section">
      <h2>èªè¨€è¨­å®š</h2>
      <label
        >ä¾†æºèªè¨€:
        <select id="sourceLang">
          <option value="zh">ä¸­æ–‡</option>
          <option value="en">English</option>
        </select>
      </label>
      <label
        >ç›®æ¨™èªè¨€:
        <select id="targetLang">
          <option value="en">English</option>
          <option value="zh">ä¸­æ–‡</option>
        </select>
      </label>
    </div>

    <div class="section">
      <h2>æ¸¬è©¦åŠŸèƒ½</h2>
      <button class="test" onclick="testTranslation()">æ¸¬è©¦ç¿»è­¯</button>
      <button class="start" onclick="startRecording()">é–‹å§‹éŒ„éŸ³</button>
      <button class="stop" onclick="stopRecording()">åœæ­¢éŒ„éŸ³</button>
    </div>

    <div class="section">
      <h2>åŸæ–‡é€å­—ç¨¿</h2>
      <div
        id="original-text"
        style="
          min-height: 100px;
          border: 1px solid #ccc;
          padding: 10px;
          background: #f9f9f9;
        "
      >
        ç­‰å¾…èªéŸ³è¼¸å…¥...
      </div>
    </div>

    <div class="section">
      <h2>ç¿»è­¯çµæœ</h2>
      <div
        id="translated-text"
        style="
          min-height: 100px;
          border: 1px solid #ccc;
          padding: 10px;
          background: #f9f9f9;
        "
      >
        ç­‰å¾…ç¿»è­¯çµæœ...
      </div>
    </div>

    <div class="section">
      <h2>æ—¥èªŒ</h2>
      <div id="log" class="log"></div>
      <button onclick="clearLog()">æ¸…é™¤æ—¥èªŒ</button>
    </div>

    <script>
      let ws = null;
      let isRecording = false;
      let audioContext = null;
      let processor = null;
      let source = null;
      let stream = null;

      function log(message) {
        const logDiv = document.getElementById("log");
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `[${timestamp}] ${message}\n`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      function clearLog() {
        document.getElementById("log").innerHTML = "";
      }

      function connectWebSocket() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          log("WebSocket å·²ç¶“é€£ç·š");
          return;
        }

        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.hostname}:3000`;

        log(`å˜—è©¦é€£æ¥åˆ°: ${wsUrl}`);
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          log("âœ… WebSocket é€£ç·šå·²å»ºç«‹");
          document.getElementById("connection-status").textContent = "å·²é€£ç·š";
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            log(`ğŸ“¥ æ”¶åˆ°è¨Šæ¯: ${JSON.stringify(data, null, 2)}`);

            switch (data.type) {
              case "transcript":
                if (data.data.is_final) {
                  log(`ğŸ“ æ”¶åˆ°æœ€çµ‚é€å­—ç¨¿: ${data.data.utterance.text}`);
                  document.getElementById("original-text").textContent =
                    data.data.utterance.text;
                }
                break;
              case "translation":
                log(`ğŸŒ æ”¶åˆ°ç¿»è­¯: ${data.data.translated_utterance.text}`);
                document.getElementById("translated-text").textContent =
                  data.data.translated_utterance.text;
                break;
              case "recording_started":
                log("ğŸ¤ éŒ„éŸ³å·²é–‹å§‹");
                break;
              case "recording_stopped":
                log("ğŸ›‘ éŒ„éŸ³å·²åœæ­¢");
                break;
              case "error":
                log(`âŒ éŒ¯èª¤: ${data.message}`);
                break;
              case "translation_error":
                log(`âŒ ç¿»è­¯éŒ¯èª¤: ${data.error}`);
                break;
            }
          } catch (error) {
            log(`âŒ è§£æè¨Šæ¯å¤±æ•—: ${error.message}`);
          }
        };

        ws.onclose = (event) => {
          log(`ğŸ”Œ WebSocket é€£ç·šå·²é—œé–‰: ${event.code} ${event.reason}`);
          document.getElementById("connection-status").textContent = "æœªé€£ç·š";
        };

        ws.onerror = (error) => {
          log(`âŒ WebSocket éŒ¯èª¤: ${error}`);
        };
      }

      function disconnectWebSocket() {
        if (ws) {
          ws.close();
          ws = null;
        }
      }

      function testTranslation() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          log("âŒ WebSocket æœªé€£ç·š");
          return;
        }

        log("ğŸ§ª ç™¼é€æ¸¬è©¦é…ç½®...");
        ws.send(
          JSON.stringify({
            type: "config",
            sourceLang: document.getElementById("sourceLang").value,
            targetLang: document.getElementById("targetLang").value,
          })
        );
      }

      async function startRecording() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          log("âŒ WebSocket æœªé€£ç·š");
          return;
        }

        if (isRecording) {
          log("âš ï¸ å·²ç¶“åœ¨éŒ„éŸ³ä¸­");
          return;
        }

        try {
          log("ğŸ¤ è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...");
          stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              sampleRate: 16000,
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          log("âœ… éº¥å…‹é¢¨æ¬Šé™å·²ç²å¾—");

          // ç™¼é€é…ç½®è¨Šæ¯
          ws.send(
            JSON.stringify({
              type: "config",
              sourceLang: document.getElementById("sourceLang").value,
              targetLang: document.getElementById("targetLang").value,
            })
          );

          // å‰µå»º AudioContext
          audioContext = new (window.AudioContext || window.webkitAudioContext)(
            {
              sampleRate: 16000,
            }
          );

          // å‰µå»ºéŸ³è¨Šæº
          source = audioContext.createMediaStreamSource(stream);

          // å‰µå»º ScriptProcessorNode
          processor = audioContext.createScriptProcessor(4096, 1, 1);

          processor.onaudioprocess = (event) => {
            if (!isRecording) return;

            const inputBuffer = event.inputBuffer;
            const inputData = inputBuffer.getChannelData(0);

            // è½‰æ›ç‚º PCM 16-bit
            const pcmData = new Int16Array(inputData.length);
            for (let i = 0; i < inputData.length; i++) {
              pcmData[i] = Math.max(
                -32768,
                Math.min(32767, inputData[i] * 32768)
              );
            }

            // è½‰æ›ç‚º base64
            const base64Pcm = btoa(
              String.fromCharCode(...new Uint8Array(pcmData.buffer))
            );

            // ç™¼é€åˆ° WebSocket
            ws.send(
              JSON.stringify({
                type: "audio_chunk",
                data: { chunk: base64Pcm },
              })
            );
          };

          // é€£æ¥éŸ³è¨Šç¯€é»
          source.connect(processor);
          processor.connect(audioContext.destination);

          isRecording = true;
          log("ğŸ¤ é–‹å§‹éŒ„éŸ³");
        } catch (error) {
          log(`âŒ ç„¡æ³•é–‹å§‹éŒ„éŸ³: ${error.message}`);
        }
      }

      function stopRecording() {
        if (!isRecording) {
          log("âš ï¸ æ²’æœ‰åœ¨éŒ„éŸ³");
          return;
        }

        isRecording = false;

        if (stream) {
          stream.getTracks().forEach((track) => track.stop());
          stream = null;
        }

        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }

        if (processor) {
          processor.disconnect();
          processor = null;
        }

        if (source) {
          source.disconnect();
          source = null;
        }

        // ç™¼é€åœæ­¢éŒ„éŸ³è¨Šæ¯
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "stop_recording",
            })
          );
        }

        log("ğŸ›‘ åœæ­¢éŒ„éŸ³");
      }

      // é é¢è¼‰å…¥æ™‚è‡ªå‹•é€£ç·š
      window.onload = () => {
        connectWebSocket();
      };
    </script>
  </body>
</html>
